Bronwyn Boydon virus_discoveries.txt


1) 

To identify the species which the protein samples came from, I used a blastp search on the Non-redundant protein sequences (nr) database. As there were only two samples, I could use the web-based ncbi blast. The top matches had 100% identity for seq_1 and 99% identify for seq_2. Both had an e-value of 0.0. Both sequences were matched to adeno-associated virus capsid proteins with genbank accession numbers: AAC58045.1 and AAS99241.1, respectively. This information has been manually saved into the protein_information.csv file to complete the next step.

If this search had failed, I would have tried different databases, and failing that, done a tbalstn search to compare the protein sequences against translated nucleotide sequences, however, this would take longer. 

2)

fast_fasta.py --> fast_fasta.fasta
blast_fasta.py --> file_fasta.fasta, blast_fasta.fasta

I have created two scrips which can complete this task. Both take the .txt files directly from a folder to parse them and output a .fasta file. 

The fast_fasta.py script uses the protein_information.csv from the previous step to create the sequence descriptions. This script runs entirely locally.

The blast_fasta.py script runs a blast search by calling NCBIWWW and uses the top matches from that to populate the sequence descriptions. This requires an uninterrupted internet connection. This method removes the need to manually search for the sequences. However, it does take longer to run, and depends on how much NCBI resources are being used at a given moment.

If there were many protein sequences to be identified, it would be best to create a local database and run the blast search locally from a python script or from the command line, because the NCBI resources are limited and not designed for very large searches.  

3)

I chose to do global pairwise alignment to compare these sequences to eachother because blast search indicates that they are similar proteins, and they are of similar length. If the proteins had been evolutionarily distant, of significantly different lengths, or the reason for the alignment was to identify shared functional protein domains, I would conduct a local alignment instead.

4)

command line Clustal Omega --> clustalo_multiple_alignment.fasta
command line EMBOSS needle --> needle_pairwise_alignment.needle
pairwise_alignment.py --> pairwise_alignment.txt

Pairwise aligners and multiple sequence aligners can be accessed via the web, downloadable software, biopython, or the command line. 

For a one off alignment, my first choice would be to use a web server because they are very intuitive and often provide nice visualisations. For more frequent use, I would use command line applications such as Clustal Omega for multiple alignments or EMBOSS needle for a global pairwise alignment. I have run both of these and included the outputs: clustalo_multiple_alignment.fasta and needle_pairwise_alignment.needle. The clustalo file can be viewed in a text editor or visualised in software such as BioEdit Sequence Alignment Editor. The needle file can be opened in a text editor to be read. 

I also used the biopython Bio.Align module to perform a pairwise alignment with settings used to replicate the EMBOSS needle aligner. This is more difficult to set up but gives some more flexibility with the settings, and is useful if the alignment needs to be run locally but there are no command line facilities. I have also formatted the output to replicate the EMBOSS needle output. Bio.Align does not distinguish between 'structurally similar' and 'structurally different' mismatches like needle does, so the outputs are not identical. The most important consideration would be to ensure that any alignments which were to be compared with others had been aligned using the same software with the same settings. 

Settings for both alignments:

# Matrix: EBLOSUM62
# Gap_penalty: 10.0
# Extend_penalty: 0.5

5)

Results from the EMBOSS needle alignment:

Length: 752
Identity:     478/752 (63.6%)
Similarity:   564/752 (75.0%)
Gaps:          33/752 ( 4.4%)
Score: 2491.5

Results from Python Bio.Align alignment:
Length: 	748
Identity: 	63.2%
Gaps: 		6.1%
Score: 		2432.0

The lengths are different because there can be multiple correct alignments for the same alignment score. In both cases, the identity score (the number of identical amino acids in the same locations) is around 63%. The Bio.Align alignment does not indicate the structural similar amino acids, so it is not possible to calculate a similarity score. This also impacts the Gap score because some of the bases which contribute to the Gap score in the Bio.Align, would instead contribute to the similarity score in needle. 

6)

Phylogenetics:
Functional prediction:
Host prediction:
Structural analysis:
Local alignment: For specific protein or functional protein domains
Visualising the alignments:



7)
